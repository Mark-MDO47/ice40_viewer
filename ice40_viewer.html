<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ICE40 layout viewer</title>

<style>
html {
  background-color: white;
  color: black;
}
#canvas1 {
  display: block;
  width: 70%;
  height: 100%;
  border: 1px solid #000000;
}
#sidebar {
    padding: 0.5em;
    position: absolute;
    box-sizing: border-box;
    right: 0;
    top: 0;
    width: 30%;
}
#netname {
    background-color: white;
    color: #cc0000;
</style>

  <script type="text/javascript" src="myutil.js"></script>
  <script type="text/javascript" src="gfx.js"></script>
  <script type="text/javascript" src="ice40.js"></script>
  <script type="text/javascript" src="lutfunction.js"></script>
</head>
<body>

  <canvas id="canvas1"> </canvas>
  <div id="sidebar">
    <h1>ICE40 floorplan</h1>
    <h2>
      <span id="statustext">Loading...</span>
    </h2>
    <hr/>
    <div><h2>Load .asc: <input type="file" id="ascfileinput"/></h2></div>
    <hr/>
    <div><h2>Zoom level:
        <input id="zoomlevel" type="range" min=0 max=1000 oninput="zoom_change();" onchange="zoom_change();" style="vertical-align: middle;"/>
    </h2></div>
    <div><input id="cb_netnums" type="checkbox" onchange="input_redraw();"/>Show net numbers</div>
    <div><input id="cb_spans" type="checkbox" checked onchange="input_redraw();"/>Show spans</div>
    <div><input id="cb_locals" type="checkbox" checked onchange="input_redraw();"/>Show locals</div>
    <div><input id="cb_drawall" type="checkbox" onchange="input_reset();"/>Draw all spans</div>
    <hr/>
    <p>See below for notes and links.</p>
  </div>

  <h1>ICE40 floorplan/layout viewer</h1>

  <p>This is a Javascript application to view the floorplan/layout of an
  ICE40 FPGA configuration generated
    by <a href="http://www.clifford.at/icestorm/">project Icestorm</a>.
    Particular focus is on drawing the actual routing of signals through span4
    and span12 wires, to give an idea of how the actual routing looks down on the chip.
  </p>

  <p>Upload the target *.asc file using the file upload widget on the right.
  After a few seconds to process the input file, the result will be
    displayed on the main canvas. NOTE: at the moment, only HX8K devices are
    supported.</p>

  <p>More detail is shown at deeper zoom levels. Zooming is available using the
     mouse wheel, or with the "+" and "-" keys, or the slider to the right.
     Click+drag left mouse to pan, or use the arrow keys.
  </p>

  <p>By hovering over a wire (on a zoom level where wires are visible), the
  connected nets will be high-lighted, and the name of the
  net will be displayed in the sidebar on the right, if a symbol was
    available in the *.asc file.</p>

  <p>Tiles that contain active cells are high-lighted. LUT functions are
    shown as boolean expression in A, B, C, D, or as a truth-table.</p>
  <p>Tiles are colour-coded as
    <span style="background-color: #EEAAEE; color: black">Logic tile</span>,
    <span style="background-color: #EEEEAA; color: black">Block ram</span>, or
    <span style="background-color: #AAEEEE; color: black">IO tile</span>.
  </p>

  <p>This is work in progress, currently not all connections are shown.</p>

  <p>This program is Free Software, licensed under an <a href="LICENSE">ISC
  License</a>. Source code is available on
  the <a href="https://github.com/knielsen/ice40_viewer">Github
  page</a>.</p>

  <p>Contact: Kristian Nielsen &lt;knielsen@knielsen-hq.org&gt;</p>

  <script>

var datafilename = [ "chipdb-8k.txt" ];
var ascfilename = [ "bramtest.asc" ];

var chipdb = { };
var g_asc_data = { };
var g_symtable = { };
var g_tiles;
var g_net_connection;
var g_supernets;

var dataLoadComplete = false;
var mouseDown = false;
var draggingMouse = false;
var dragStartX, dragStartY;
var dragStartViewX0, dragStartViewX1, dragStartViewY0, dragStartViewY1;

var view_x0, view_x1, view_y0, view_y1


function setZoomFromSlider() {
    var slider = document.getElementById("zoomlevel");
    var sliderValue = slider.value;
    // Normalise to 0..1.
    sliderValue = (sliderValue - slider.min)/(slider.max - slider.min);
    // Min zoom is when everything is visible, -1..width.
    // Max zoom is set at 1/10 of a tile.
    // Make an exponential zoom, VISIBLE = A*exp(-B*sliderValue)
    // VISIBLE(0) = SIZE+1 => A=SIZE+1
    // VISIBLE(1) = 0.1    => B=log(A/0.1)
    var A = chipdb.device.width+1;
    var B = Math.log(A/0.1);
    var visibleX = A*Math.exp(-B*sliderValue);
    A = chipdb.device.height+1;
    B = Math.log(A/0.1);
    var visibleY = A*Math.exp(-B*sliderValue);
    // Update zoom, keeping center of canvas the same.
    var midX = 0.5*(view_x0 + view_x1);
    var midY = 0.5*(view_y0 + view_y1);
    view_x0 = midX - 0.5*visibleX;
    view_x1 = midX + 0.5*visibleX;
    view_y0 = midX - 0.5*visibleY;
    view_y1 = midX + 0.5*visibleY
    scheduleRedraw();
}


// Update zoom slider to match current zoom level.
// Basically computes the inverse function from setZoomFromSlider().
function updateZoomSlider() {
    var visibleX = view_x1 - view_x0;
    var A = chipdb.device.width+1;
    var B = Math.log(A/0.1);
    var sliderValue = Math.log(A/visibleX)/B;
    if (sliderValue < 0)
	sliderValue = 0;
    else if (sliderValue > 1)
	sliderValue = 1;
    var slider = document.getElementById("zoomlevel");
    slider.value = slider.min + (slider.max - slider.min)*sliderValue;
}


function resetZoom() {
    // Initialise zoom to have all tiles visible.
    view_x0 = -1;
    view_x1 = chipdb.device.width;
    view_y0 = -1;
    view_y1 = chipdb.device.height;
    updateZoomSlider();
}


function wheelHandler(event) {
    // Zoom the view.

    if (!dataLoadComplete)
	return true;

    var canvas = document.getElementById("canvas1");
    var cx = event.pageX - canvas.offsetLeft;
    var cy = event.pageY - canvas.offsetTop;
    var wld = canvas2world(canvas, cx, cy);
    var wx = wld[0];
    var wy = wld[1];
    zoomStep(event.deltaY, wx, wy);
    event.preventDefault();
    return false;
}


// Zoom a given number of steps (negative to zoom in, positive out).
// The center-of-zoom is (wx, wy), in world coordinates.
function zoomStep(step, wx, wy) {
    var del = Math.pow(1.023, step);
    var a1 = wx - view_x0;
    var a2 = view_x1 - wx;
    var b1 = wy - view_y0;
    var b2 = view_y1 - wy;
    view_x0 = wx - del*a1;
    view_x1 = wx + del*a2;
    view_y0 = wy - del*b1;
    view_y1 = wy + del*b2;
    updateZoomSlider();
    scheduleRedraw();
}


function keyHandler(event) {
    if (!dataLoadComplete)
	return true;
    if (event.key == "Home") {
	resetZoom();
	scheduleRedraw();
	event.preventDefault();
	return false;
    }
    if (event.key == "+") {
	zoomStep(-10, 0.5*(view_x0 + view_x1), 0.5*(view_y0 + view_y1));
	event.preventDefault();
	return false;
    }
    if (event.key == "-") {
	zoomStep(10, 0.5*(view_x0 + view_x1), 0.5*(view_y0 + view_y1));
	event.preventDefault();
	return false;
    }
    if (event.key == " ") {
	// ToDo: cycle perma-select.
    }
    if (event.key == "ArrowLeft" || event.key == "ArrowRight") {
	// Pan left/right.
	var del = 0.05*(view_x1 - view_x0);
	if (event.key == "ArrowLeft")
	    del = -del;
	view_x0 += del;
	view_x1 += del;
	scheduleRedraw();
	event.preventDefault();
	return false;
    }
    if (event.key == "ArrowUp" || event.key == "ArrowDown") {
	// Pan up/down.
	var del = 0.05*(view_y1 - view_y0);
	if (event.key == "ArrowDown")
	    del = -del;
	view_y0 += del;
	view_y1 += del;
	scheduleRedraw();
	event.preventDefault();
	return false;
    }
    return true;
}


function mouseDownHandler(event) {
    if (!dataLoadComplete)
	return true;

    var canvas = document.getElementById("canvas1");
    var cx = event.pageX - canvas.offsetLeft;
    var cy = event.pageY - canvas.offsetTop;
    mouseDown = true;
    dragStartX = cx;
    dragStartY = cy;
    dragStartViewX0 = view_x0;
    dragStartViewX1 = view_x1;
    dragStartViewY0 = view_y0;
    dragStartViewY1 = view_y1;
    return true;
}


function mouseUpHandler(event) {
    mouseDown = false;
    draggingMouse = false;

    if (!dataLoadComplete)
	return true;

    return true;
}


function mouseMoveHandler(event) {
    if (!dataLoadComplete)
	return true;

    var canvas = document.getElementById("canvas1");
    var cx = event.pageX - canvas.offsetLeft;
    var cy = event.pageY - canvas.offsetTop;

    // Handle mouse-over highlighting.
    if (cx >= 0 && cx < canvas.width && cy >= 0 && cy < canvas.height) {
	var tc = canvas2TileXY(canvas, cx, cy);
	var oldHighlight = highLightSupernet;
	checkWireHighlight(tc[0], tc[1], tc[2], tc[3]);
	if (oldHighlight != highLightSupernet) {
	    document.getElementById("statustext").innerHTML =
		"Net: <span id='netname'>" + getHighlightedNetLabel() + "</span>";
	    scheduleRedraw();
	}
    } else {
	if (highLightSupernet != undefined) {
	    highLightSupernet = undefined;
	    scheduleRedraw();
	}
    }

    // Handle mouse drag, for panning.
    if (!mouseDown)
	return true;
    var dx = cx - dragStartX;
    var dy = cy - dragStartY;
    if (!draggingMouse && dx*dx + dy*dy > 5*5)
	draggingMouse = true;

    if (draggingMouse) {
	var delx = dx/canvas.width*(dragStartViewX1-dragStartViewX0);
	var dely = dy/canvas.height*(dragStartViewY1-dragStartViewY0);
	view_x0 = dragStartViewX0 - delx;
	view_x1 = dragStartViewX1 - delx;
	view_y0 = dragStartViewY0 + dely;
	view_y1 = dragStartViewY1 + dely;
	scheduleRedraw();
    }

    return true;
}


function focusOutHandler(event) {
    mouseDown = false;
    draggingMouse = false;
    return true;
}


function setupEventHandlers() {
    canvas = document.getElementById("canvas1");
    canvas.addEventListener("wheel", wheelHandler, false);
    document.addEventListener("keypress", keyHandler, true);
    canvas.addEventListener("mousedown", mouseDownHandler, false);
    document.addEventListener("mouseup", mouseUpHandler, false);
    document.addEventListener("mousemove", mouseMoveHandler, false);
    document.addEventListener("focusout", focusOutHandler, false);

    var fileinput = document.getElementById("ascfileinput");
    fileinput.addEventListener("change", readDotAsc, false);
}


function zoom_change() {
    setZoomFromSlider();
}


function input_redraw() {
    scheduleRedraw();
}


function input_reset() {
    reparseFileData();
}


// Redrawing management.

var needRedraw = false;

function redrawIfNeeded() {
    if (needRedraw) {
	redraw();
	needRedraw = false;
	// var txt;
	// if (highLightSupernet != undefined)
	//     txt = getHighlightedNetLabel();
	// else
	//     txt = "View: " +
	//     "X: " + Math.floor(view_x0 + 0.5).toString() +
	//     ".." + Math.ceil(view_x1 - 0.5).toString() +
	//     "  Y: " + Math.floor(view_y0 + 0.5).toString() +
	//     ".." + Math.ceil(view_y1 - 0.5).toString();
	// document.getElementById("statustext").textContent = txt
    }
}

// Do redraws asynchroneously. This way, if a slow redraw causes multiple updates
// to queue up meanwhile, we only need a single extra redraw to handle all pending
// updates, and we avoid updates getting too lagged.
function scheduleRedraw() {
    needRedraw = true;
    //document.getElementById("statustext").textContent = "Redrawing...";
    setTimeout(redrawIfNeeded, 0);
}


function redraw() {
    var canvas = document.getElementById("canvas1");
    var c = canvas.getContext("2d");
    var wx = canvas.width;
    var wy = canvas.height;
    var cliw = canvas.clientWidth;
    var clih = canvas.clientHeight;
    if (wx != cliw || wy != clih) {
	canvas.width = wx = cliw;
	canvas.height = wy = clih;
    }

    c.fillStyle = "#FFFFFF";
    c.fillRect(0, 0, wx, wy);
    c.strokeStyle = "#000000";
    c.lineWidth = 1;

    var showNetNumbers = document.getElementById("cb_netnums").checked;
    var drawSpans = document.getElementById("cb_spans").checked;
    var drawLocals = document.getElementById("cb_locals").checked;
    drawTiles(canvas, showNetNumbers, drawSpans, drawLocals);

    // Flash any high-lighted net.
    if (highLightSupernet != undefined)
	setTimeout(scheduleRedraw, 250);
}


var chipdb_loaded = false;
var asc_file_fetched = false;
var asc_file_parser;

function maybe_parse_asc() {
    if (!chipdb_loaded || !asc_file_fetched)
	return;
    drawAll = document.getElementById("cb_drawall").checked;
    g_asc_data = { };
    g_symtable = new Array(chipdb.device.num_nets);
    asc_parse_step(asc_file_parser, chipdb, g_tiles, g_symtable, g_asc_data, function() {
	document.getElementById("statustext").textContent = ".asc loaded ok";
	asc_file_parser = null;
	asc_postprocess(chipdb, g_tiles, g_asc_data);
	calcTiles(g_tiles);
	dataLoadComplete = true;
	scheduleRedraw();
    });
}


var g_fileData;

function reparseFileData() {
    asc_file_parser = getLineParser(g_fileData);
    g_tiles = mk_tiles(chipdb);
    maybe_parse_asc();
}


function readDotAsc(event) {
    if (!chipdb_loaded || !asc_file_fetched)
	return;
    var file = event.target.files[0];
    if (!file)
	return;
    var fr = new FileReader();
    fr.onload = function (dataEvent) {
	g_fileData = dataEvent.target.result;
	reparseFileData();
    }
    fr.readAsText(file);
}


function loaddata() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
	if (xhr.readyState == 4) {
	    if (xhr.status == 200) {
		document.getElementById("statustext").textContent = "ChipDB loaded ok";
		chipdb = { };
		var parser = getLineParser(xhr.responseText);
		chipdb_parse_step(parser, chipdb, function (loaded_chipdb) {
		    console.log("Loaded: " + loaded_chipdb.device.device + " size " + chipdb.device.width + "x" + chipdb.device.height + " @ " + chipdb.device.num_nets + " nets.");

		    chipdb_loaded = true;
		    resetZoom();

		    // Initialise a tiles array for drawing.
		    g_tiles = mk_tiles(chipdb);
		    maybe_parse_asc();
		    scheduleRedraw();
		});
	    } else {
		document.getElementById("statustext").innerHTML = "<b>Error loading chipdb data (HTTP code: " + xhr.status + "</b>";
	    }
	}
    };
    xhr.open("GET", datafilename, true);
    xhr.responseType = "text";
    xhr.send();

    var xhr2 = new XMLHttpRequest();
    xhr2.onreadystatechange = function() {
	if (xhr2.readyState == 4) {
	    if (xhr2.status == 200) {
		asc_file_fetched = true;
		g_fileData = xhr2.responseText;
		asc_file_parser = getLineParser(g_fileData);
		maybe_parse_asc();
	    } else {
		document.getElementById("statustext").innerHTML = "<b>Error loading .asc data (HTTP code: " + xhr2.status + "</b>";
	    }
	}
    };
    xhr2.open("GET", ascfilename, true);
    xhr2.responseType = "text";
    xhr2.send();
}

setupEventHandlers();
loaddata();

  </script>

</body>
</html>
